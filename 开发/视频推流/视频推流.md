
# 摩尔线程适配
目标平台：FT-D3000(arm) + MTT X300，麒麟V10系统

## 官方文档
> [MT Smart Media | Moore Threads](https://developer.mthreads.com/musa/smart-media)

### MT Video Codec SDK
> [MT Video Codec SDK | Moore Threads](https://developer.mthreads.com/sdk/download/mt_video_codec_sdk)

摩尔线程的GPU中包含多个硬件视频编解码器，能够提供丰富的视频解码、编码和转码服务。通过调用GPU的编解码能力，可以大幅提升编解码效率、降低延迟与功耗，并降低CPU负载。

|   版本  |  说明  | 
| --- | --- |
|  MTEncode_v1.2.0   |   一个windows平台下mtencodeapi64.dll使用demo  |
|ffmpeg_4.4.2&libva2.20|amd-linux的ffmpeg和libva的deb安装包|

#### 1.  MTEncode_v1.2.0
```cpp
#include <windows.h>
void MTEncoder::GetMTEncApi()
{
#if defined(_WIN64)
    HMODULE hModule = LoadLibrary(TEXT("mtencodeapi64.dll"));
#else
    HMODULE hModule = LoadLibrary(TEXT("mtencodeapi32.dll"));
#endif

    if (hModule == NULL)
    {
        MTENC_THROW_EXCEPTION(
            "MTENC library is not found. Please ensure MT driver is installed", MT_ENC_ERR_NO_ENCODE_DEVICE);
    }

    m_hModule = hModule;

    typedef MTENCSTATUS(MTENCAPI * MTEncodeAPIGetMaxSupportedVersion_Type)(uint32_t*);
    MTEncodeAPIGetMaxSupportedVersion_Type pfGetMaxSupportedVersion =
        (MTEncodeAPIGetMaxSupportedVersion_Type)GetProcAddress(hModule, "MTEncodeAPIGetMaxSupportedVersion");

    uint32_t version        = 0;
    uint32_t currentVersion = MTENCAPI_VERSION;
    MTENC_API_CALL(pfGetMaxSupportedVersion(&version));
    if (currentVersion > version)
    {
        MTENC_THROW_EXCEPTION(
            "Current Driver Version does not support this MTEncodeAPI version, please upgrade driver",
            MT_ENC_ERR_INVALID_VERSION);
    }

    typedef MTENCSTATUS(MTENCAPI * MTEncodeAPICreateInstance_Type)(MT_ENCODE_API_FUNCTION_LIST*);
    MTEncodeAPICreateInstance_Type pfCreateInstance =
        (MTEncodeAPICreateInstance_Type)GetProcAddress(hModule, "MTEncodeAPICreateInstance");

    if (!pfCreateInstance)
    {
        MTENC_THROW_EXCEPTION(
            "Cannot find MTEncodeAPICreateInstance() entry in MTENC library", MT_ENC_ERR_NO_ENCODE_DEVICE);
    }

    m_mtEnc = {MTENCAPI_VERSION};
    MTENC_API_CALL(pfCreateInstance(&m_mtEnc));
}
```
这里直接加载了mtencodeapi64.dll，不知道在linux平台是否有对应的实现
只看到Windows平台的实现
#### 2. ffmpeg_4.4.2&libva2.20
ffmpeg_4.4.2_x86_64.deb  libva_2.20_x86_64.deb

# Vulkan视频拓展

## vk_video_samples
> https://github.com/nvpro-samples/vk_video_samples

![vk_video_samples/vk_video_decoder/doc/VideoDecode.png at main · nvpro-samples/vk_video_samples](https://github.com/nvpro-samples/vk_video_samples/blob/main/vk_video_decoder/doc/VideoDecode.png?raw=true)

本项目是一个 Vulkan 视频示例应用程序，演示了如何完全使用 Vulkan 处理 h.264/5、AV1 压缩的视频内容。该应用程序使用硬件加速解码器解码压缩内容，解码后的 YCbCr 帧通过 Vulkan 图形处理，然后通过 Vulkan WSI 进行显示。

目前，该示例应用程序支持 Linux 和 Windows 10 操作系统。

### 特征[](https://github.com/nvpro-samples/vk_video_samples#features)

- [x] 使用 h.264 (AVC)、h.265 (HEVC) 或 AV1 压缩格式，从 .mp4、.mkv、.mov 和其他视频容器中提取（通过 FFMPEG 解复用）压缩视频。
- [x] 硬件视频解码器将纹理处理成 Vulkan 视频图像，可以直接从 Vulkan 采样器（纹理）进行采样。
- [x] 使用 [VK_KHR_sampler_ycbcr_conversion](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VK_KHR_sampler_ycbcr_conversion.html) 对解码后的图像进行采样，同时将 YCbCr (YUV) 图像转换为 RGB 图像。
- [x] 使用 Vulkan WSI 显示后处理的视频帧。
- [ ] 在 WSI 端使用视频显示时序同步（例如 VK_EXT_present_timing）——目前视频以显示设备支持的最大帧速率播放。视频的播放速率可能高于其制作速率。

有关如何构建示例解码应用程序的说明，请参阅[构建说明。](https://github.com/KhronosGroup/Vulkan-Video-Samples/blob/main/BUILD.md)

请下载并安装启用 [Vulkan 视频功能的 NVIDIA 测试版驱动程序](https://developer.nvidia.com/vulkan-driver) 。

有关 Vulkan 视频规范，请参阅 [Vulkan 视频扩展规范](https://www.khronos.org/registry/vulkan/specs/1.2-extensions/html/vkspec.html) 。

有关 Vulkan 视频的深入信息，请参阅[深度解析幻灯片](https://www.khronos.org/assets/uploads/apis/Vulkan-Video-Deep-Dive-Apr21.pdf) [双语对照](Vulkan-Video-Deep-Dive-Apr21_billingual.pdf)。