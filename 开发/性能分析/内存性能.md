
```cpp
{  
    const auto test_mark = StopWatch(true);  
    std::vector<uint8_t> test;  
    test.resize(y_size + uv_size); // 388804 字节
    LOG_INFO("resize call cost: {}ms", test_mark.stop_ms());  
}
```
vector无优化，两次内存申请，初始化申请1字节内存，resize申请`y_size + uv_size`字节内存， 同时申请完内存会进行初始化（清零）：
![[e632cb0e-5f91-424c-a3a6-6e2907225b5b.png]]

```cpp
std::vector<uint8_t, CachingAllocator<uint8_t>> test;
```
vector + CachingAllocator：
![[Pasted image 20251202103620.png]]

```cpp
{  
    const auto test_mark = StopWatch(true);  
    auto test = std::allocate_shared_for_overwrite<uint8_t[]>(CachingAllocator<uint8_t>{}, y_size + uv_size);  
    LOG_INFO("resize call cost: {}ms", test_mark.stop_ms());  
}
```
![[Pasted image 20251202110834.png]]
```cpp
{  
    const auto test_mark = StopWatch(true);  
    auto test = std::make_shared_for_overwrite<uint8_t[]>(/*CachingAllocator<uint8_t>{},*/ y_size + uv_size);  
    LOG_INFO("resize call cost: {}ms", test_mark.stop_ms());  
}
```
![[Pasted image 20251202111658.png]]

```cpp
{  
    const auto test_mark = StopWatch(true);  
    auto test = std::allocate_shared<uint8_t[]>(CachingAllocator<uint8_t>{}, y_size + uv_size);  
    LOG_INFO("resize call cost: {}ms", test_mark.stop_ms());  
}
```
![[Pasted image 20251202112733.png]]

```cpp
{  
    const auto test_mark = StopWatch(true);  
    auto test = std::make_shared<uint8_t[]>(/*CachingAllocator<uint8_t>{},*/ y_size + uv_size);  
    LOG_INFO("resize call cost: {}ms", test_mark.stop_ms());  
}
```
![[Pasted image 20251202111837.png]]

std::make_shared 和 vector::resize性能接近，make_shared_for_overwrite可以内存无初始化对于大块内存可以节省大量执行时间