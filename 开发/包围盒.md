# Unity
存放在`Renderer`中

|接口|类型|空间|说明|
|---|---|---|---|
|**`bounds`**|属性|世界空间|**最常用**，获取世界空间AABB|
|**`localBounds`**|属性|局部空间|某些Renderer类型可用|

## **最常用的组件关系**

| 类别     | 基类                    | 重要派生类                         | 作用       |
| ------ | --------------------- | ----------------------------- | -------- |
| **脚本** | MonoBehaviour         | 所有自定义脚本                       | 游戏逻辑     |
| **渲染** | Renderer              | MeshRenderer, SpriteRenderer  | 视觉显示     |
| **碰撞** | Collider/Collider2D   | BoxCollider, CircleCollider2D | 物理碰撞     |
| **物理** | Rigidbody/Rigidbody2D | -                             | 物理模拟     |
| **变换** | Transform             | -                             | 位置/旋转/缩放 |
| **音频** | AudioSource           | -                             | 播放声音     |
| **动画** | Animator              | -                             | 控制动画状态机  |
| **UI** | CanvasRenderer        | -                             | UI元素渲染   |

## **Unity Component 继承树**
```
UnityEngine.Object (所有Unity对象的基类)
└── Component (所有组件的基类)
    ├── Transform
    ├── Behaviour (可启用/禁用的组件)
    |   ├── MonoBehaviour (用户脚本)
    |   │   └── 所有自定义脚本继承自此
    |   ├── Camera (相机)
    |   │   ├── 透视/正交相机
    |   │   └── 渲染目标控制
    |   ├── Light (光源)
    |   │   ├── Directional Light (平行光)
    |   │   ├── Point Light (点光源)
    |   │   ├── Spot Light (聚光灯)
    |   │   └── Area Light (区域光)
    |   ├── AudioSource (音频源)
    |   ├── AudioListener (音频接收器)
    |   ├── ParticleSystem (粒子系统)
    |   ├── Animator (动画控制器)
    |   ├── Animation (旧版动画)
    |   └── NavMeshAgent (导航网格代理)
    ├── Renderer (渲染相关)
    |   ├── MeshRenderer (静态网格渲染器)
    |   ├── SkinnedMeshRenderer (蒙皮网格渲染器)
    |   ├── SpriteRenderer (2D精灵渲染器)
    |   ├── LineRenderer (线条渲染器)
    |   ├── TrailRenderer (拖尾渲染器)
    |   ├── ParticleSystemRenderer (粒子渲染器)
    |   └── BillboardRenderer (广告牌渲染器)
    ├── Collider (3D碰撞体)
    │   ├── BoxCollider
    │   ├── SphereCollider
    │   ├── CapsuleCollider
    │   ├── MeshCollider
    │   └── WheelCollider
    ├── Rigidbody (3D刚体)
    ├── Collider2D (2D碰撞体)
    │   ├── BoxCollider2D
    │   ├── CircleCollider2D
    │   ├── PolygonCollider2D
    │   └── EdgeCollider2D
    ├── Rigidbody2D (2D刚体)
    └── CanvasRenderer (UI渲染)
```

- **Transform**: 只负责变换
- **Renderer**: 只负责渲染
- **Collider**: 只负责碰撞检测
- **Rigidbody**: 只负责物理模拟
### **为什么Renderer不继承Behaviour？**

根据官方文档讨论，**Renderer直接继承Component**的原因：

- **性能优化**：避免不必要的enabled状态检查
- **设计分离**：渲染是底层系统，不完全是"行为"
- **历史原因**：Unity早期架构设计决定

# UE
存放在`USceneComponent`中
## **控制包围盒行为的标志变量**

| 变量                                              | 类型      | 说明                                     |
| ----------------------------------------------- | ------- | -------------------------------------- |
| **`bUseAttachParentBound`**                     | `uint8` | 如果为true，此组件使用其父组件的包围盒（优化性能）            |
| **`bBoundsChangeTriggersStreamingDataRebuild`** | `uint8` | 如果为true，组件包围盒的变化会触发流式数据重建              |
| **`bComputeBoundsOnceForGame`**                 | `uint8` | 如果为true，组件在烹饪或PIE期间缓存其包围盒，之后不再重新计算     |
| **`bComputedBoundsOnceForGame`**                | `uint8` | 如果为true，组件已缓存其包围盒，不再重新计算               |
| **`bComputeFastLocalBounds`**                   | `uint8` | 如果为true，使用当前包围盒转换回局部空间，而不是调用CalcBounds |
## **主要接口列表**

| 类型       | 接口                          | 作用               |
| -------- | --------------------------- | ---------------- |
| **公开变量** | `Bounds`                    | 组件的当前世界空间包围盒     |
| **方法**   | `GetLocalBounds()`          | 获取局部空间包围盒        |
| **虚方法**  | `CalcLocalBounds()`         | 计算局部空间包围盒（可重写）   |
| **虚方法**  | `CalcBounds()`              | 计算任意变换下的包围盒（可重写） |
| **虚方法**  | `CalcBoundingCylinder()`    | 计算包围圆柱体          |
| **虚方法**  | `UpdateBounds()`            | 更新包围盒            |
| **标志**   | `bUseAttachParentBound`     | 是否使用父组件的包围盒      |
| **标志**   | `bComputeBoundsOnceForGame` | 是否缓存包围盒          |

```cpp
/** Get the current local bounds of the component */
FBoxSphereBounds USceneComponent::GetLocalBounds() const
{
	if (bComputeFastLocalBounds)
	{
		return Bounds.TransformBy(ComponentToWorld.Inverse());
	}

	if (GLocalBoundsUseAttachParentBound && bUseAttachParentBound && GetAttachParent() != nullptr)
	{
		return GetAttachParent()->Bounds.TransformBy(ComponentToWorld.Inverse());
	}

	return CalcBounds(FTransform::Identity);
}
	
/** Calculate the bounds of the component. Default behavior is a bounding box/sphere of zero size. */
FBoxSphereBounds USceneComponent::CalcBounds(const FTransform& LocalToWorld) const
{
	FBoxSphereBounds NewBounds;
	NewBounds.Origin = LocalToWorld.GetLocation();
	NewBounds.BoxExtent = FVector::ZeroVector;
	NewBounds.SphereRadius = 0.f;
	return NewBounds;
}

/** Calculate the local bounds of the component. Default behavior is calling CalcBounds with an identity transform. */
virtual FBoxSphereBounds CalcLocalBounds() const 
{ 
	return GetLocalBounds();
}
```

# **UE为什么将包围盒（Bounds）存放在SceneComponent中？**

基于对Unreal Engine官方文档和架构设计的分析，**将包围盒存储在SceneComponent中是经过深思熟虑的设计决策**，主要基于以下核心原因：

## **一、设计哲学：SceneComponent的本质是“空间表示”**

### **1. SceneComponent的核心职责**
根据Unreal Engine官方文档和社区讨论（如Reddit上的技术分析），**SceneComponent的核心设计理念就是“空间表示”（Spatial Representation）**。

> "SceneComponent is a physical representation as well, one might argue, but SceneComponents represent space, which is a physical representation."

**关键点**：
- **Scene**（场景）本身就意味着空间位置
- **Component**（组件）是功能单元
- **SceneComponent = 具有空间位置的功能单元**

### **2. 包围盒是空间属性的自然延伸**
```cpp
// SceneComponent的三大核心属性
class USceneComponent : public UActorComponent {
    FVector RelativeLocation;  // 位置 ← 空间属性
    FRotator RelativeRotation; // 旋转 ← 空间属性  
    FVector RelativeScale3D;   // 缩放 ← 空间属性
    
    FBoxSphereBounds Bounds;   // 包围盒 ← 空间属性的计算结果
};
```

**逻辑关系**：位置+旋转+缩放 → 计算得出 → 包围盒

---

## **二、架构优势：统一管理所有空间组件**

### **1. 继承树的一致性**
```
UActorComponent (所有组件基类)
├── USceneComponent (所有空间组件基类)
    ├── UPrimitiveComponent (所有可渲染/可碰撞组件)
    │   ├── UStaticMeshComponent
    │   ├── USkeletalMeshComponent
    │   └── ...
    └── UCameraComponent
    └── ULightComponent
    └── ...
```

**设计优势**：
- **所有需要空间变换的组件**都继承自SceneComponent
- **所有需要包围盒的组件**都自动获得Bounds支持
- **避免重复代码**：不用在每个子类中重新实现包围盒计算

### **2. 性能优化的统一入口**
因为包围盒计算在基类中，UE可以实施**全局性能优化策略**：

```cpp
// SceneComponent提供的优化标志
class USceneComponent {
    uint8 bUseAttachParentBound : 1;       // 使用父组件包围盒（优化）
    uint8 bComputeBoundsOnceForGame : 1;   // 游戏运行时缓存包围盒
    uint8 bComputeFastLocalBounds : 1;     // 快速计算局部包围盒
};
```

**实际效果**：
- 子组件可以共享父组件的包围盒（`bUseAttachParentBound`）
- 静态物体只需计算一次包围盒（`bComputeBoundsOnceForGame`）
- 优化整个场景的包围盒计算性能

---

## **三、渲染系统需求：可见性剔除的核心**

### **1. 官方文档证实：包围盒用于可见性测试**
根据Unreal Engine官方文档《Visibility and Occlusion Culling》：

> "Each Actor placed in a Level has a set of bounds using a box and a sphere that is used for various things in the Engine. One of those being specifically to test whether an it is visible or not."

**关键用途**：
- **视锥体剔除**（View Frustum Culling）
- **硬件遮挡查询**（Hardware Occlusion Queries）
- **层次深度缓冲剔除**（Hierarchical Z-Buffer Occlusion）

### **2. 剔除系统的依赖关系**
```
渲染管线需要知道：
1. 物体在哪里？        ← SceneComponent.RelativeLocation
2. 物体有多大？        ← SceneComponent.Bounds
3. 物体是否在视野内？   ← 基于Bounds的视锥体测试

如果Bounds不在SceneComponent中，剔除系统需要：
1. 查找Renderer组件
2. 查找Collider组件  
3. 合并多个组件的Bounds
→ 性能低下且复杂
```

---

## **四、对比Unity的设计差异**

### **Unity的设计（分散存储）**
```
GameObject
├── Transform           ← 位置/旋转/缩放
├── Renderer           ← 包围盒（bounds属性）
├── Collider           ← 碰撞包围盒
└── ...其他组件

问题：不同组件的包围盒需要手动协调
```

### **Unreal的设计（集中存储）**
```
AActor
└── USceneComponent (Root)
    ├── FTransform      ← 位置/旋转/缩放（包含在Component中）
    ├── FBoxSphereBounds ← 包围盒（存储在Component中）
    └── 其他功能...

优势：空间数据集中管理，一致性更好
```

**关键区别**：Unity的Transform是独立组件，而UE的变换信息直接内嵌在SceneComponent中。

---

## **五、实际开发中的好处**

### **1. 代码简洁性**
```cpp
// 获取任何SceneComponent的包围盒（无需类型检查）
FBoxSphereBounds GetComponentBounds(USceneComponent* Comp) {
    return Comp->Bounds;  // 直接访问，所有SceneComponent都有
}

// 而如果放在PrimitiveComponent中：
FBoxSphereBounds GetPrimitiveBounds(UPrimitiveComponent* Prim) {
    return Prim->Bounds;  // 只能用于PrimitiveComponent
}
```

### **2. 编辑器集成**
- **所有SceneComponent**在编辑器中都可以显示包围盒
- **可视化调试**统一通过`Show > Advanced > Bounds`显示
- **Bounds Scale**设置对所有空间组件生效

### **3. 网络同步优化**
对于网络游戏，**只需要同步SceneComponent的变换**，包围盒可以自动重新计算，减少网络数据传输。

---

## **六、从引擎源码角度的验证**

### **1. SceneComponent.h中的关键注释**
根据对UE源码的分析，SceneComponent的Bounds设计考虑了：

```cpp
// 引擎源码中的设计思想（简化）：
// 1. 所有需要空间表示的组件都应该有包围盒
// 2. 包围盒应该跟随变换自动更新
// 3. 应该提供优化选项减少计算开销

// 当变换更新时，自动更新包围盒
void USceneComponent::UpdateComponentToWorld() {
    // ...更新变换...
    UpdateBounds();  // 自动更新包围盒
}
```

### **2. 性能优化的层级设计**
```
Level 1: bUseAttachParentBound = true    ← 完全共享父组件包围盒
Level 2: bComputeBoundsOnceForGame = true ← 运行时缓存
Level 3: bComputeFastLocalBounds = true   ← 快速近似计算
Level 4: 完全动态计算（默认）

这种分级优化只有在基类中实现才有意义
```

---

## **七、总结：三大核心原因**

### **1. 架构一致性**
> **“空间属性应该与空间计算放在一起”**
- 位置、旋转、缩放 → 自然需要 → 包围盒计算
- 所有空间组件 → 都应该有 → 包围盒支持

### **2. 性能优化统一**
> **“在基类中优化，所有子类受益”**
- 包围盒缓存策略（`bComputeBoundsOnceForGame`）
- 父子组件共享（`bUseAttachParentBound`）
- 快速计算模式（`bComputeFastLocalBounds`）

### **3. 渲染系统需求**
> **“可见性剔除需要所有空间组件的包围盒”**
- 视锥体剔除：需要知道物体是否在相机视野内
- 遮挡剔除：需要知道物体是否被其他物体挡住
- 距离剔除：需要知道物体与相机的距离

**最终结论**：UE将Bounds存放在SceneComponent中，是因为**包围盒本质上是空间属性的计算结果**，将其放在空间组件的基类中，符合面向对象设计原则，提供了统一的优化入口，并满足了渲染系统对空间查询的核心需求。

*验证来源：Unreal Engine官方文档《Visibility and Occlusion Culling》、USceneComponent API文档、引擎社区技术分析*