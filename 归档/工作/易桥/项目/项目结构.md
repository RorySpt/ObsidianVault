项目中有以下内容：
- **[[#交互式工具框架]]**
- **[[#Lyra 部分系统]]**
- **[[#仿真管理系统]]**
- **[[#车辆武器系统]]**
- **[[#车辆设计]]**

其中**交互式工具框架**，**仿真管理系统**，**车辆武器系统**在**SimBase**插件中

**CommonUI**部分直接移植的Lyra的UI系统，/Game/Source下面的大部分代码基本上都是，参见：[https://DESKTOP-6MTNAKK/svn/LyraStarterGame/trunk](https://DESKTOP-6MTNAKK/svn/LyraStarterGame/trunk)


# 交互式工具框架

> InteractiveToolsFramework, ITF

参考自[[ToolsFrameworkDemo]]

实现在/SimBase/Source/Framework下


移植到项目中后对其做了以下改动：

## 选中相关

可选中内容由SenceObject改为Actor，**选中逻辑**可查看`USceneObjectSelectionInteraction::OnClickRelease`

**框选效果**在/Game/UI/WBP_DrawArea中实现，可将其放于任意需要显示的HUD中，已经添加到/Game/UI/Hud/W_GDSHUDLayout中

## ToolsContextActor
实现继承自`ATacticalEditorPawn`，用于接入输入时间，将事件转发给ITF。ITF的所有输出都来自这里，鼠标左键事件，撤销/重做事件等等

`ATacticalEditorPawn`对右键事件做了特殊处理，右键按下时鼠标锁定并且指针消失用以操作视角，抬起显示。要想正确工作，`ULyraActivatableWidget`的输入设置务必保证为默认值
```cpp
/** The desired input mode to use while this UI is activated, for example do you want key presses to still reach the game/player controller? */  
UPROPERTY(EditDefaultsOnly, Category = Input)  
ELyraWidgetInputMode InputConfig = ELyraWidgetInputMode::GameAndMenu;  
  
/** The desired mouse behavior when the game gets input. */  
UPROPERTY(EditDefaultsOnly, Category = Input)  
EMouseCaptureMode GameMouseCaptureMode = EMouseCaptureMode::CaptureDuringMouseDown;  
  
UPROPERTY(EditDefaultsOnly, Category = Input)  
EMouseLockMode MouseLockMode = EMouseLockMode::LockOnCapture;  
  
UPROPERTY(EditDefaultsOnly, Category = Input)  
bool bHideCursorDuringViewportCapture = false;
```

## 测量工具

实现了两种，**线测量工具**（RuntimeDistanceMeasurementTool）和**面积测量工具**（RuntimeDrawPolygonTool），在 /SimBase/Source/Framework/Tools 下面

**面积测量工具**直接修改TFD的**多边形绘制工具**（RuntimeDrawPolygonTool），仅限制为平面绘制
**线测量工具** 是参考TFD的**多边形绘制工具**进行的实现

`UMeasurementSubsystem`存放所有绘制的线；面积测量结果为`DynamicMeshActor`，可以从`URuntimeObjectSceneSubsystem::ListDynamicMeshActor`中获取

**线测量工具**可以完成**距离测量**，**方位测量**和**坡度测量**，由`URuntimeDistanceMeasurementToolBuilder::LineMode`配置，`UMeasurementDistance::LineMode`存储以指示 /Game/NC_GDS/CommonUI/Test/W_TestGameMenu 去显示不同效果



# Lyra 部分系统
主要是Lyra的UI系统，CommonUI

## 场景加载
使用
```cpp
UCommonSession_HostSessionRequest* UGDSSystemLibrary::CreateHostingRequest(const UObject* WorldContextObject,  const FTinyExperienceDefinition Experience, USimScenario* SimScenario)
```

```cpp
/** Description of settings used to display experiences in the UI and start a new session */  
USTRUCT(BlueprintType)  
struct FTinyExperienceDefinition  
{  
    GENERATED_BODY()  
  
public:  
    /** Indicates if the session is a full online session or a different type */  
    UPROPERTY(BlueprintReadWrite, Category=Session)  
    ECommonSessionOnlineMode OnlineMode = ECommonSessionOnlineMode::Offline;  
      
    /** The specific map to load */  
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Experience, meta=(AllowedTypes="Map"))  
    FPrimaryAssetId MapID;  
  
    /** The gameplay experience to load */  
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Experience, meta=(AllowedTypes="LyraExperienceDefinition"))  
    FPrimaryAssetId ExperienceID;  
  
    /** Extra arguments passed as URL options to the game */  
    UPROPERTY(BlueprintReadWrite, EditAnywhere, Category=Experience)  
    TMap<FString, FString> ExtraArgs;  
};
```
`FTinyExperienceDefinition`中MapID为要加载的关卡，ExperienceID是关卡加载时执行的动作，用以配置关卡加载时要执行的动作，比如添加主界面，设置HUD等等，可以为空

OnlineMode必须为ECommonSessionOnlineMode::Offline，Online模式未完全测试

每个关卡都必须设置一个默认可自定义的 Experience，这个实现定义在ALyraWorldSettings中
![[Pasted image 20250707145214.png]]

配置可以参考/Game/Developers/Administrator/Maps/B_TestMap_ExperienceDefinition，如图：
![[Pasted image 20250707150607.png|1000]]
## Lyra的 UI系统

UI系统是从Lyra项目中移植过来的，使用方式几乎一致（可能有缺失的地方），可以参考：[https://DESKTOP-6MTNAKK/svn/LyraStarterGame/trunk](https://DESKTOP-6MTNAKK/svn/LyraStarterGame/trunk)

Lyra中UI由/Game/UI/W_OverallUILayout（UPrimaryGameLayout）管理
![[Pasted image 20250707153836.png]]
默认有四个堆栈层级，分别为：
- UI.Layer.Game - 类似 HUD
- UI.Layer.GameMenu - 与游戏玩法相关的“菜单”，例如游戏内物品栏 UI
- UI.Layer.Menu - 类似设置屏幕的内容
- UI.Layer.Modal - 确认对话框、错误对话框

> 摘自蓝图注释：
> You will push/pop or push/deactivate to different layers.  If something new is put onto the GameMenu layer, while another thing is on it, it will stop displaying the old UI, and show the new one until the new one is deactivated (which pops it).
>
> If you put something on an entirely different layer, like the Menu, all layers below it will still be visibile, because each of these layers is a seperate stack of widgets.
>
> The Layer widgets can be any widget that subclasses from UCommonActivatableWidgetContainerBase, so if you wwanted you could make the modal stack a UCommonActivatableWidgetQueue, and suddenly any time you pushed modal content onto the modal layer, it would operate like a queue, waiting for the modal in front to be dealt with before the modal next in line can activate.

可以使用`UCommonUIExtensions::PushContentToLayer`系列函数向堆栈添加Widget，或者使用行为`UAsyncAction_PushContentToLayerForPlayer`

关于堆栈的内容可查找`CommonUI`的`UCommonActivatableWidgetStack`的相关资料

`W_OverallUILayout`会在`GameInstance::AddLocalPlayer`执行时自行添加到`Viewport`中，`ZOrder`为$1000$

建议 UI.Layer.Game 层添加ULyraHUDLayout的派生类，可以添加挂载点，可通过
```cpp
FUIExtensionHandle UUIExtensionSubsystem::RegisterExtensionAsWidgetForContext(const FGameplayTag& ExtensionPointTag, UObject* ContextObject, TSubclassOf<UUserWidget> WidgetClass, int32 Priority)
```
向挂载点添加控件，同一个Tag的挂载点在不同的控件中是一致的

UI.Layer.GameMenu层添加`ULyraActivatableWidget`，其可以设置同时操作界面和场景

UI.Layer.Menu 一般为全屏控件，可以使用 UCommonActivatableWidget，它会停掉场景的输入

UI.Layer.Modal层，添加UCommonGameDialog的子控件，不建议使用PushContent进行添加，可以使用：
```cpp
UAsyncAction_ShowConfirmation* UAsyncAction_ShowConfirmation::ShowConfirmationYesNo(UObject* InWorldContextObject, FText Title, FText Message)  
  
UAsyncAction_ShowConfirmation* UAsyncAction_ShowConfirmation::ShowConfirmationOkCancel(UObject* InWorldContextObject, FText Title, FText Message)  
  
UAsyncAction_ShowConfirmation* UAsyncAction_ShowConfirmation::ShowConfirmationCustom(UObject* InWorldContextObject, UCommonGameDialogDescriptor* Descriptor)  
```
界面定义在 `ULyraUIMessaging::ConfirmationDialogClass`，可以在 DefaultGame.ini 进行配置

如需拓展自行参照上述函数的实现进行拓展。


# 仿真管理系统

关于仿真的一些知识参见[[仿真基本概念]]

## 序列化
序列化采用开源 json 库 nlohmann_json，参见：[https://github.com/nlohmann/json](https://github.com/nlohmann/json)
UE主要类的序列化器：Plugins/SimBase/Source/SimBase/Utils/Json/UnrealJsonSerializers.hpp

## 实体管理
*实体管理子系统：Plugins/SimBase/Source/SimBase/Gameplay/Subsystem/EntityManagerSubsystem.h*

通过对仿真实体添加 USimEntityComponent， 其会自动将 Owner 记录到 UEntityManagerSubsystem 子系统中

UEntityManagerSubsystem 具有管理当前场景中的仿真实体的能力，包括查询，清理，序列化到Json，从Json反序列化等

当仿真实体被添加到场景中或者被销毁时，UEntityManagerSubsystem会产生委托事件

> [!Tip]
> USimEntityComponent 是一个记录与仿真相关的实体数据的好地方，因为每个仿真实体都具有该组件

## 仿真管理
*仿真管理子系统：Plugins/SimBase/Source/SimBase/Gameplay/Subsystem/SimManagerSubsystem.h*
*想定保存路径：Saved/plans*

SimManagerSubsystem 负责控制仿真的开始和结束，同时还记录了仿真时间，当前想定文件等信息

SimManagerSubsystem 具有管理想定文件的能力，可以列出所有想定文件，删除，保存，加载想定文件

## 仿真想定对象

**想定名称**（USimScenarioName）由名字和创建时间构成，是想定的唯一索引
提供字符串和**想定名称**的相互转换：
```cpp
// 想定名称到字符串
FString USimManagerSubsystem::DumpScenarioName(FSimScenarioName ScenarioName);
// 字符串到想定名称，如：ScenarioName = "Scenario-Test-0001.01.01-00.00.00"
bool USimManagerSubsystem::ParseScenarioName(FString ScenarioName, FSimScenarioName& Result);
```

通过想定名称可以创建一个**想定对象**（USimScenario），当想定被创建时，它可能存在本地文件，也可能不存在，可以通过自身的`HasDiskInstance()`方法查询。

本地想定文件必须通过加载才能被使用。

**想定对象**保存时，会直接覆盖掉同名的本地文件

通过**想定对象**可以将当前仿真场景保存到该想定对象中，或者把想定对象中保存的想定加载到场景中。




# 车辆武器系统

武器系统参见[[武器设计]]
伤害系统参见[[伤害系统设计]]

**重要内容：**
发射物基类：Plugins/SimBase/Source/SimBase/Gameplay/Entity/Equipment/Projectile/ProjectileBase.h
武器组件基类：Plugins/SimBase/Source/SimBase/Gameplay/Entity/Equipment/Weapon/VehicleWeaponComponent.h
武器瞄准方法：Plugins/SimBase/Source/SimBase/Gameplay/Entity/Equipment/Weapon/WeaponMathLibrary.h
伤害子系统：Plugins/SimBase/Source/SimBase/Gameplay/Entity/Equipment/Damage/DamageSubsystem.h
默认**发射物伤害表**：Saved/DamageTable/Default.json

车辆要实现`IWeaponControlInterface`的接口才能被武器正确操纵。

`WeaponID`跟武器对应的值需要自己设计，建议从0开始。

**弹道武器**炮类可以参考`UPrimaryCannonComponent`，连发武器参考`UMachineGunComponent`

`UPrimaryCannonComponent`和`UMachineGunComponent`的`DefaultProjectile`必须被设置才能正常工作，它是要打出发射物的类型，其中包含必要的弹道数据。Projectile可能不止一种，之后可以考虑改成运行时动态选择的。

**制导武器**暂未实现，可以参考 **BetterHomingProjectiles** 插件的实现



**发射物**需要继承自 `AProjectileBase` (Plugins/SimBase/Source/SimBase/Gameplay/Entity/Equipment/Projectile/ProjectileBase.h)
可参考已有实现：
- AP穿甲弹：/Game/Developers/Administrator/Blueprints/BP_APShell
- 762x55mm子弹：/Game/Developers/Administrator/Blueprints/BP_Bullet_762x55mm
发射物伤害需要在**发射物伤害表**中配置。

或者在代码中添加，以向默认伤害表中添加BP_Bullet_762x55mm的伤害配置为例：
![[Pasted image 20250710172456.png|1000]]



# 车辆设计

>坦克教程： [How to make a Tank](https://youtu.be/rqs5Tfmb9bU?si=H0S4T8T4xZJSgBhd)

履带车辆可以参考PTZ89：
- 资产路径：/All/Game/Art/weapon/PTZ89_BANG
- 蓝图路径：/Game/Blueprint/Vehicle/BP_PTZ89

履带车辆要继承自：/Game/Blueprint/Traffic/BP_BaseTrackVehicle，非履带车辆继承：/Game/Blueprint/Traffic/BP_BaseVehicle

拿到美术给的骨骼网格体后，需要创建**动画蓝图资产**，**物理资产**，**ControlRig资产**，以及**车辆蓝图资产**，可以直接复制已有的实现

## ControlRig资产
**ControlRig资产**主要负责履带和负重轮的贴合。复制已有资产，以复制PTZ89为例：
![[Pasted image 20250710164435.png|500]]
如图，重新选择网格体，同时注意`TracksFollowWheels`函数中轮子名称是否正确

## 物理资产
**物理资产**中删除所有已有形体，然后勾选显示所有形体
![[Pasted image 20250710163548.png|300]]
以PTZ89为例，添加根骨骼形体，和所有轮子的形体，其他可选（如炮塔和炮管）。根骨骼形体的物理类型选为模拟，其余为运动学
![[Pasted image 20250710163942.png|1000]]

## 动画蓝图资产
**动画蓝图资产**建议直接复制已有蓝图，如PTZ89。然后在类设置里面把`Target Skeleton`选择为对应的骨骼。

ControlRig节点修改ControlClass 为上面创建的[[#ControlRig资产]]

注意动画图表中骨骼名称和履带更新中的骨骼名称是否正确：
![[Pasted image 20250710165436.png|700]] ![[Pasted image 20250710165528.png|1000]]

## 车辆蓝图资产

**车辆蓝图资产**建议直接复制已有蓝图，如PTZ89。设置对应的骨骼网格体和动画蓝图。

检查武器组件是否正确：
- PTZ89有两个武器组件，主炮和机枪，确认当前装备是否有这两个武器。
- 注意武器组件的`Weapon ID`和`Default Projectile`是否正确。

检查接口中`GetWeaponRay`和`AimTo`函数实现是否正确

勾选`Show Trajectory`选项可以显示当前武器的弹道。


